import {
  IReportsRepository,
  ExtendedReportRun,
  ReportTemplate,
  RunReportParams,
  SaveTemplateParams,
  ReportRunFilters,
  ReportRunListResult,
} from "@/domain/interfaces/IReportsRepository";
import { ReportDefinition, reportDefinitions } from "@/types/reportsAndLogs";
import { mockReportRuns } from "@/data/mockReportsLogs";
import { Role } from "@/types/tokenization";
import { ReportOutputFormat } from "@/types/reportsAndLogs";

/**
 * Mock implementation of IReportsRepository
 * Uses existing mockReportRuns and reportDefinitions
 */
export class MockReportsRepository implements IReportsRepository {
  private runs: ExtendedReportRun[];
  private templates: ReportTemplate[] = [];

  constructor() {
    // Convert existing mock runs to extended format
    this.runs = mockReportRuns.map(run => ({
      ...run,
    }));
  }

  getAvailableReports(role: Role): ReportDefinition[] {
    return reportDefinitions.filter(def => def.requiredRoles.includes(role));
  }

  async saveTemplate(params: SaveTemplateParams): Promise<ReportTemplate> {
    const template: ReportTemplate = {
      templateId: `tpl-${Date.now()}`,
      reportType: params.reportType,
      name: params.name,
      description: params.description,
      ownerUserId: params.ownerUserId,
      ownerName: params.ownerName,
      parameters: params.parameters,
      createdAt: new Date().toISOString(),
    };

    this.templates.push(template);
    return template;
  }

  async listTemplates(userId: string): Promise<ReportTemplate[]> {
    return this.templates.filter(t => t.ownerUserId === userId);
  }

  async getTemplate(templateId: string): Promise<ReportTemplate | null> {
    return this.templates.find(t => t.templateId === templateId) ?? null;
  }

  async deleteTemplate(templateId: string): Promise<void> {
    const index = this.templates.findIndex(t => t.templateId === templateId);
    if (index >= 0) {
      this.templates.splice(index, 1);
    }
  }

  async runReport(params: RunReportParams): Promise<ExtendedReportRun> {
    const definition = reportDefinitions.find(d => d.type === params.reportType);
    
    const run: ExtendedReportRun = {
      id: `run-${Date.now()}`,
      reportType: params.reportType,
      reportName: definition?.name ?? params.reportType,
      params: params.parameters,
      generatedBy: params.generatedBy,
      generatedByName: params.generatedByName,
      generatedAt: new Date().toISOString(),
      outputFormat: params.outputFormat,
      rowCount: Math.floor(Math.random() * 500) + 50, // Mock row count
      status: "COMPLETED",
      exportReason: params.exportReason,
    };

    this.runs.unshift(run);

    // Update template's lastRunAt if applicable
    if (params.templateId) {
      const template = this.templates.find(t => t.templateId === params.templateId);
      if (template) {
        template.lastRunAt = run.generatedAt;
      }
    }

    return run;
  }

  async listReportRuns(filters: ReportRunFilters): Promise<ReportRunListResult> {
    let filtered = [...this.runs];

    // Apply report type filter
    if (filters.reportType && filters.reportType !== "all") {
      filtered = filtered.filter(run => run.reportType === filters.reportType);
    }

    // Apply status filter
    if (filters.status && filters.status !== "all") {
      filtered = filtered.filter(run => run.status === filters.status);
    }

    // Apply generated by filter
    if (filters.generatedBy) {
      filtered = filtered.filter(run => run.generatedBy === filters.generatedBy);
    }

    // Apply date filters
    if (filters.dateFrom) {
      const fromDate = new Date(filters.dateFrom);
      filtered = filtered.filter(run => new Date(run.generatedAt) >= fromDate);
    }
    if (filters.dateTo) {
      const toDate = new Date(filters.dateTo);
      filtered = filtered.filter(run => new Date(run.generatedAt) <= toDate);
    }

    // Sort by date descending
    filtered.sort((a, b) => new Date(b.generatedAt).getTime() - new Date(a.generatedAt).getTime());

    // Apply pagination
    const total = filtered.length;
    const offset = filters.offset ?? 0;
    const limit = filters.limit ?? 20;
    const paginated = filtered.slice(offset, offset + limit);

    return {
      runs: paginated,
      total,
      hasMore: offset + paginated.length < total,
    };
  }

  async getReportRun(runId: string): Promise<ExtendedReportRun | null> {
    return this.runs.find(run => run.id === runId) ?? null;
  }

  async exportReport(runId: string, format: ReportOutputFormat): Promise<string> {
    // Mock file URI generation
    const timestamp = Date.now();
    return `https://storage.accountabul.io/reports/${runId}-${timestamp}.${format.toLowerCase()}`;
  }
}

// Singleton instance
export const mockReportsRepository = new MockReportsRepository();
